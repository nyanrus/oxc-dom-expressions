# AST-Based Code Generation in oxc-dom-expressions

This document explains how oxc-dom-expressions follows Oxc's best practices for AST-based code transformation, as outlined in the "Oxc AST Injection Patterns for Transformers" document.

## Overview

**oxc-dom-expressions does NOT use string-based code generation.** Instead, all JavaScript code is generated by constructing AST (Abstract Syntax Tree) nodes using Oxc's `AstBuilder` API. This approach provides:

- **Type Safety**: The compiler ensures all generated code is syntactically correct
- **Performance**: Direct AST manipulation is faster than parsing generated strings
- **Maintainability**: AST construction is more explicit and easier to debug
- **Correctness**: No risk of injection attacks or malformed code

## Core Principles

### 1. Manual AST Construction

All AST nodes are created using the `AstBuilder` API accessed through `self.allocator`:

```rust
// ✅ CORRECT: AST-based generation
let call_expr = CallExpression {
    span: SPAN,
    callee: Expression::Identifier(Box::new_in(
        IdentifierReference {
            span: SPAN,
            name: Atom::from("_$insert"),
            reference_id: None.into(),
        },
        self.allocator,
    )),
    arguments: args,
    optional: false,
    type_arguments: None,
    pure: false,
};

// ❌ WRONG: String-based generation (never do this)
let code = format!("_$insert({}, {})", element, value);
```

### 2. Single Pass Transformation

All transformations happen in a single traversal of the AST using the `Traverse` trait:

```rust
impl<'a> Traverse<'a> for DomExpressions<'a> {
    fn exit_expression(&mut self, expr: &mut Expression<'a>, ctx: &mut TraverseCtx<'a>) {
        // Transform JSX elements into DOM manipulation code
        if let Expression::JSXElement(jsx_elem) = expr {
            *expr = self.transform_jsx_element(jsx_elem, ctx);
        }
    }
}
```

### 3. Two Code Injection Patterns

#### Pattern 1: Node Replacement

Replace AST nodes in `exit_*` methods:

```rust
fn exit_expression(&mut self, expr: &mut Expression<'a>, ctx: &mut TraverseCtx<'a>) {
    if let Expression::JSXElement(jsx_elem) = expr {
        // Replace JSX with generated code
        *expr = self.transform_jsx_element(jsx_elem, ctx);
    }
}
```

#### Pattern 2: Statement Insertion

Insert new statements into statement blocks:

```rust
// Create new statement
let insert_stmt = self.create_insert_call(element_var, expression, marker);

// Insert into statements vector
statements.push(insert_stmt);
```

## Implementation Examples

### Example 1: Creating a Function Call

Generate: `_$insert(element, value, null)`

```rust
pub fn create_insert_call_with_marker(
    &self,
    element_var: &str,
    expr: &Expression<'a>,
    marker_var: Option<&str>,
) -> Option<Statement<'a>> {
    use oxc_allocator::CloneIn;
    use oxc_ast::ast::*;

    // Create function identifier: _$insert
    let insert_fn = IdentifierReference {
        span: SPAN,
        name: Atom::from("_$insert"),
        reference_id: None.into(),
    };

    // First argument: element reference
    let elem_arg = Argument::Identifier(Box::new_in(
        IdentifierReference {
            span: SPAN,
            name: Atom::from(self.allocator.alloc_str(element_var)),
            reference_id: None.into(),
        },
        self.allocator,
    ));

    // Second argument: expression (clone it)
    let expr_arg = Argument::from(expr.clone_in(self.allocator));

    // Third argument: marker or null
    let marker_arg = if let Some(marker) = marker_var {
        Argument::Identifier(Box::new_in(
            IdentifierReference {
                span: SPAN,
                name: Atom::from(self.allocator.alloc_str(marker)),
                reference_id: None.into(),
            },
            self.allocator,
        ))
    } else {
        Argument::NullLiteral(Box::new_in(NullLiteral { span: SPAN }, self.allocator))
    };

    // Build arguments vector
    let mut args = OxcVec::new_in(self.allocator);
    args.push(elem_arg);
    args.push(expr_arg);
    args.push(marker_arg);

    // Create call expression: _$insert(element, value, null)
    let call_expr = CallExpression {
        span: SPAN,
        callee: Expression::Identifier(Box::new_in(insert_fn, self.allocator)),
        arguments: args,
        optional: false,
        type_arguments: None,
        pure: false,
    };

    // Wrap in expression statement
    Some(Statement::ExpressionStatement(Box::new_in(
        ExpressionStatement {
            span: SPAN,
            expression: Expression::CallExpression(Box::new_in(call_expr, self.allocator)),
        },
        self.allocator,
    )))
}
```

### Example 2: Creating an Assignment

Generate: `element.$$click = handler`

```rust
pub fn create_delegated_event_handler(
    &self,
    element_var: &str,
    event_name: &str,
    handler_expr: &Expression<'a>,
) -> Option<Statement<'a>> {
    use oxc_allocator::CloneIn;
    use oxc_ast::ast::*;

    // Normalize event name
    let normalized_event = event_name.to_lowercase();

    // Create: element
    let element_ref = IdentifierReference {
        span: SPAN,
        name: Atom::from(self.allocator.alloc_str(element_var)),
        reference_id: None.into(),
    };

    // Create property name: $$click
    let prop_name = format!("$${}", normalized_event);
    let prop_ident = IdentifierName {
        span: SPAN,
        name: Atom::from(self.allocator.alloc_str(&prop_name)),
    };

    // Create member expression: element.$$click
    let member_expr = StaticMemberExpression {
        span: SPAN,
        object: Expression::Identifier(Box::new_in(element_ref, self.allocator)),
        property: prop_ident,
        optional: false,
    };

    // Create assignment: element.$$click = handler
    let assignment = AssignmentExpression {
        span: SPAN,
        operator: AssignmentOperator::Assign,
        left: AssignmentTarget::from(SimpleAssignmentTarget::from(
            MemberExpression::StaticMemberExpression(Box::new_in(member_expr, self.allocator)),
        )),
        right: handler_expr.clone_in(self.allocator),
    };

    // Wrap in statement
    Some(Statement::ExpressionStatement(Box::new_in(
        ExpressionStatement {
            span: SPAN,
            expression: Expression::AssignmentExpression(Box::new_in(
                assignment,
                self.allocator,
            )),
        },
        self.allocator,
    )))
}
```

### Example 3: Creating Import Statements

Generate: `import { template as _$template } from "solid-js/web"`

```rust
pub fn create_import_statements(&self) -> Vec<Statement<'a>> {
    use oxc_ast::ast::*;

    let mut statements = Vec::new();

    for import_name in &self.required_imports {
        // Create local binding: _$template
        let local_name = format!("_${}", import_name);
        let local = BindingIdentifier {
            span: SPAN,
            name: Atom::from(self.allocator.alloc_str(&local_name)),
            symbol_id: None.into(),
        };

        // Create imported name: template
        let imported = ModuleExportName::IdentifierName(IdentifierName {
            span: SPAN,
            name: Atom::from(self.allocator.alloc_str(import_name)),
        });

        // Create import specifier
        let specifier = ImportDeclarationSpecifier::ImportSpecifier(Box::new_in(
            ImportSpecifier {
                span: SPAN,
                imported,
                local,
                import_kind: ImportOrExportKind::Value,
            },
            self.allocator,
        ));

        let mut specifiers = OxcVec::new_in(self.allocator);
        specifiers.push(specifier);

        // Create source: "solid-js/web"
        let source = StringLiteral {
            span: SPAN,
            value: Atom::from(self.allocator.alloc_str(&self.options.module_name)),
            raw: None,
            lone_surrogates: false,
        };

        // Create import declaration
        let import_decl = ImportDeclaration {
            span: SPAN,
            specifiers: Some(specifiers),
            source,
            with_clause: None,
            import_kind: ImportOrExportKind::Value,
            phase: None,
        };

        let module_decl = ModuleDeclaration::ImportDeclaration(
            Box::new_in(import_decl, self.allocator)
        );

        statements.push(Statement::from(module_decl));
    }

    statements
}
```

## When String Usage is Acceptable

There are specific cases where `format!()` or string operations are acceptable:

### ✅ Creating Identifier Names

```rust
// OK: Creating a property name string
let prop_name = format!("$${}", event_name);

// Then use it to create an AST node
let prop_ident = IdentifierName {
    span: SPAN,
    name: Atom::from(self.allocator.alloc_str(&prop_name)),
};
```

### ✅ Creating Literal String Values

```rust
// OK: Creating a string literal value
let css_value = format!("{}:{}", property, value);

// Then use it in an AST node
let string_lit = StringLiteral {
    span: SPAN,
    value: Atom::from(self.allocator.alloc_str(&css_value)),
    raw: None,
    lone_surrogates: false,
};
```

### ❌ Generating Code as Strings

```rust
// NEVER DO THIS: Generating JavaScript code as a string
let code = format!("const {} = {}.cloneNode(true)", element, template);
let code = format!("insert({}, {})", element, expression);
let code = format!("{}.addEventListener('{}', {})", element, event, handler);
```

## Module Organization

The codebase is organized to separate AST construction logic:

- **`src/transform/mod.rs`**: Core transformation logic and state management
- **`src/transform/codegen.rs`**: AST-based code generation helpers (NOT string-based!)
- **`src/transform/events.rs`**: Event handler AST generation
- **`src/transform/attributes.rs`**: Attribute and style AST generation
- **`src/transform/templates.rs`**: Template IIFE AST generation
- **`src/transform/components.rs`**: Component call AST generation
- **`src/transform/traverse_impl.rs`**: Traverse trait implementation

## Best Practices

### 1. Add Comments to Explain Generated Code

```rust
// Generate: _$insert(element, value, null)
let call_expr = CallExpression { /* ... */ };
```

### 2. Use Helper Methods for Complex AST Construction

```rust
// Instead of repeating AST construction:
let stmt = self.create_insert_call(element, expr, marker);

// Rather than inline AST building everywhere
```

### 3. Clone Expressions When Reusing

```rust
use oxc_allocator::CloneIn;

// Clone the expression for reuse
let expr_arg = Argument::from(expr.clone_in(self.allocator));
```

### 4. Use `Box::new_in` and `OxcVec::new_in`

```rust
// Always allocate in the arena
let boxed = Box::new_in(node, self.allocator);
let vec = OxcVec::new_in(self.allocator);
```

## Migration from String-Based Generation

If you find any string-based code generation in the codebase:

1. **Identify the pattern**: What JavaScript code is being generated?
2. **Find the AST node type**: Look up the corresponding AST type in `oxc_ast::ast`
3. **Construct the AST**: Use `AstBuilder` to create the node
4. **Test thoroughly**: Ensure the generated code matches expectations

## Testing

Tests should focus on the AST transformation, not on string output:

```rust
// ✅ Good: Test the transformation logic
#[test]
fn test_jsx_transformation() {
    let allocator = Allocator::default();
    let source = r#"<div>{count}</div>"#;
    let transformed = transform_jsx(&allocator, source);
    // Verify the AST structure or final output
}

// ❌ Bad: Test deprecated string-based utilities
#[test]
fn test_string_generation() {
    let code = generate_code("element", "value");
    assert!(code.contains("element"));
}
```

## Resources

- [Oxc AST Documentation](https://github.com/oxc-project/oxc)
- [Oxc Traverse Documentation](https://github.com/oxc-project/oxc/tree/main/crates/oxc_traverse)
- [AST Node Types](https://github.com/oxc-project/oxc/blob/main/crates/oxc_ast/src/ast)

## Conclusion

oxc-dom-expressions is fully committed to AST-based code generation. This approach aligns with Oxc's philosophy of performance, type safety, and maintainability. By avoiding string manipulation, we ensure robust, correct, and efficient transformations.
