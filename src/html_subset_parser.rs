//! HTML subset parser for template.rs output
//!
//! This parser is specifically designed to parse the well-formed HTML generated
//! by template.rs. It does NOT handle:
//! - Comments
//! - CDATA sections
//! - Doctype declarations
//! - Malformed HTML
//! - HTML entities (other than what's in the source)
//!
//! It focuses on:
//! - Elements with attributes
//! - Text nodes
//! - Proper nesting and closing tag matching
//! - Quoted and unquoted attribute values

/// HTML node types in our AST
#[derive(Debug, Clone, PartialEq)]
pub enum HtmlNode {
    Element {
        tag: String,
        attributes: Vec<(String, String)>,
        children: Vec<HtmlNode>,
        is_void: bool,
    },
    Text(String),
}

/// Parse HTML into an AST
///
/// This parser expects well-formed HTML as generated by template.rs:
/// - All tags are properly closed (except void elements)
/// - Attributes are properly quoted or unquoted
/// - No HTML comments or special constructs
pub fn parse(html: &str) -> Vec<HtmlNode> {
    let mut chars = html.chars().peekable();
    let mut nodes = Vec::new();
    
    while chars.peek().is_some() {
        if let Some(node) = parse_node(&mut chars) {
            nodes.push(node);
        }
    }
    
    nodes
}

/// Parse a single HTML node
fn parse_node(chars: &mut std::iter::Peekable<std::str::Chars>) -> Option<HtmlNode> {
    // Don't skip whitespace - preserve it as text nodes
    // The template.rs already handles formatting whitespace removal
    
    if chars.peek() == Some(&'<') {
        chars.next(); // consume '<'
        
        // Check if it's a closing tag
        if chars.peek() == Some(&'/') {
            // This is a closing tag, return None to signal end of element
            return None;
        }
        
        // Parse tag name
        let mut tag = String::new();
        while let Some(&ch) = chars.peek() {
            if ch.is_whitespace() || ch == '>' || ch == '/' {
                break;
            }
            tag.push(ch);
            chars.next();
        }
        
        // Parse attributes
        let mut attributes = Vec::new();
        loop {
            // Skip whitespace
            while let Some(&ch) = chars.peek() {
                if ch.is_whitespace() {
                    chars.next();
                } else {
                    break;
                }
            }
            
            // Check for end of tag
            if chars.peek() == Some(&'>') || chars.peek() == Some(&'/') {
                break;
            }
            
            // Parse attribute name
            let mut attr_name = String::new();
            while let Some(&ch) = chars.peek() {
                if ch == '=' || ch.is_whitespace() || ch == '>' {
                    break;
                }
                attr_name.push(ch);
                chars.next();
            }
            
            if attr_name.is_empty() {
                break;
            }
            
            // Skip whitespace
            while let Some(&ch) = chars.peek() {
                if ch.is_whitespace() {
                    chars.next();
                } else {
                    break;
                }
            }
            
            // Check for '='
            let mut attr_value = String::new();
            if chars.peek() == Some(&'=') {
                chars.next(); // consume '='
                
                // Skip whitespace
                while let Some(&ch) = chars.peek() {
                    if ch.is_whitespace() {
                        chars.next();
                    } else {
                        break;
                    }
                }
                
                // Parse attribute value
                if let Some(&quote_ch) = chars.peek() {
                    if quote_ch == '"' || quote_ch == '\'' {
                        chars.next(); // consume quote
                        while let Some(&ch) = chars.peek() {
                            if ch == quote_ch {
                                chars.next(); // consume closing quote
                                break;
                            }
                            attr_value.push(ch);
                            chars.next();
                        }
                    } else {
                        // Unquoted attribute value
                        while let Some(&ch) = chars.peek() {
                            if ch.is_whitespace() || ch == '>' {
                                break;
                            }
                            attr_value.push(ch);
                            chars.next();
                        }
                    }
                }
            }
            
            attributes.push((attr_name, attr_value));
        }
        
        // Check if self-closing or void element
        let is_void = is_void_tag(&tag);
        let mut self_closing = false;
        
        if chars.peek() == Some(&'/') {
            chars.next(); // consume '/'
            self_closing = true;
        }
        
        if chars.peek() == Some(&'>') {
            chars.next(); // consume '>'
        }
        
        // Parse children for non-void elements
        let mut children = Vec::new();
        if !is_void && !self_closing {
            loop {
                // Don't skip whitespace - it should be preserved as text content
                // The template.rs already handles formatting whitespace removal
                
                // Check for closing tag by looking ahead
                if chars.peek() == Some(&'<') {
                    let mut temp_chars = chars.clone();
                    temp_chars.next(); // consume '<'
                    
                    if temp_chars.peek() == Some(&'/') {
                        temp_chars.next(); // consume '/'
                        
                        // Check if this closing tag matches our opening tag
                        let mut closing_tag_name = String::new();
                        while let Some(&ch) = temp_chars.peek() {
                            if ch == '>' || ch.is_whitespace() {
                                break;
                            }
                            closing_tag_name.push(ch);
                            temp_chars.next();
                        }
                        
                        if closing_tag_name == tag {
                            // This is our closing tag, consume it
                            while let Some(&ch) = chars.peek() {
                                chars.next();
                                if ch == '>' {
                                    break;
                                }
                            }
                            break;
                        }
                        // Otherwise, it's a closing tag for a child element
                        // Let the recursive call handle it
                    }
                    
                    // Try to parse a child element
                    if let Some(child) = parse_node(chars) {
                        children.push(child);
                    } else {
                        // parse_node returned None, which means it hit a closing tag
                        // This closing tag is for us, so break
                        break;
                    }
                } else if chars.peek().is_some() {
                    // Parse text content (including whitespace)
                    let mut text = String::new();
                    while let Some(&ch) = chars.peek() {
                        if ch == '<' {
                            break;
                        }
                        text.push(ch);
                        chars.next();
                    }
                    if !text.is_empty() {
                        children.push(HtmlNode::Text(text));
                    }
                } else {
                    // End of input
                    break;
                }
            }
        }
        
        Some(HtmlNode::Element {
            tag,
            attributes,
            children,
            is_void,
        })
    } else {
        // Parse text content
        let mut text = String::new();
        while let Some(&ch) = chars.peek() {
            if ch == '<' {
                break;
            }
            text.push(ch);
            chars.next();
        }
        if !text.is_empty() {
            Some(HtmlNode::Text(text))
        } else {
            None
        }
    }
}

/// Check if a tag is a void element (self-closing in HTML)
fn is_void_tag(tag: &str) -> bool {
    matches!(
        tag.to_lowercase().as_str(),
        "area" | "base" | "br" | "col" | "embed" | "hr" | "img" | "input" |
        "link" | "meta" | "param" | "source" | "track" | "wbr"
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_element() {
        let html = r#"<div id="main"></div>"#;
        let nodes = parse(html);
        assert_eq!(nodes.len(), 1);
        
        if let HtmlNode::Element { tag, attributes, children, .. } = &nodes[0] {
            assert_eq!(tag, "div");
            assert_eq!(attributes.len(), 1);
            assert_eq!(attributes[0].0, "id");
            assert_eq!(attributes[0].1, "main");
            assert_eq!(children.len(), 0);
        } else {
            panic!("Expected element node");
        }
    }

    #[test]
    fn test_parse_nested_elements() {
        let html = r#"<div><button><span>0</span></button></div>"#;
        let nodes = parse(html);
        
        assert_eq!(nodes.len(), 1);
        if let HtmlNode::Element { tag, children, .. } = &nodes[0] {
            assert_eq!(tag, "div");
            assert_eq!(children.len(), 1);
            
            if let HtmlNode::Element { tag: tag2, children: children2, .. } = &children[0] {
                assert_eq!(tag2, "button");
                assert_eq!(children2.len(), 1);
                
                if let HtmlNode::Element { tag: tag3, children: children3, .. } = &children2[0] {
                    assert_eq!(tag3, "span");
                    assert_eq!(children3.len(), 1);
                    
                    if let HtmlNode::Text(text) = &children3[0] {
                        assert_eq!(text, "0");
                    } else {
                        panic!("Expected text node");
                    }
                } else {
                    panic!("Expected span element");
                }
            } else {
                panic!("Expected button element");
            }
        } else {
            panic!("Expected div element");
        }
    }

    #[test]
    fn test_parse_nested_divs() {
        let html = r#"<div><div><button></button></div></div>"#;
        let nodes = parse(html);
        
        assert_eq!(nodes.len(), 1);
        if let HtmlNode::Element { tag, children, .. } = &nodes[0] {
            assert_eq!(tag, "div");
            assert_eq!(children.len(), 1, "Outer div should have 1 child");
            
            if let HtmlNode::Element { tag: tag2, children: children2, .. } = &children[0] {
                assert_eq!(tag2, "div");
                assert_eq!(children2.len(), 1, "Inner div should have 1 child (button)");
            } else {
                panic!("Expected inner div element");
            }
        } else {
            panic!("Expected outer div element");
        }
    }

    #[test]
    fn test_parse_with_text_and_element() {
        let html = r#"<div><noscript>No JS!!<style>div</style></noscript></div>"#;
        let nodes = parse(html);
        
        if let HtmlNode::Element { children, .. } = &nodes[0] {
            if let HtmlNode::Element { tag, children: noscript_children, .. } = &children[0] {
                assert_eq!(tag, "noscript");
                assert_eq!(noscript_children.len(), 2);
                
                // First child should be text
                if let HtmlNode::Text(text) = &noscript_children[0] {
                    assert_eq!(text, "No JS!!");
                } else {
                    panic!("Expected text node");
                }
                
                // Second child should be style element
                if let HtmlNode::Element { tag: style_tag, .. } = &noscript_children[1] {
                    assert_eq!(style_tag, "style");
                } else {
                    panic!("Expected style element");
                }
            }
        }
    }

    #[test]
    fn test_parse_void_element() {
        let html = r#"<input id="test" type="text">"#;
        let nodes = parse(html);
        
        assert_eq!(nodes.len(), 1);
        if let HtmlNode::Element { tag, attributes, is_void, children, .. } = &nodes[0] {
            assert_eq!(tag, "input");
            assert_eq!(*is_void, true);
            assert_eq!(children.len(), 0);
            assert_eq!(attributes.len(), 2);
        } else {
            panic!("Expected element node");
        }
    }
}
